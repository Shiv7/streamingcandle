package com.kotsin.consumer.enrichment.intelligence.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.List;

/**
 * PredictedEvent - A forecasted market event or price action
 *
 * Predictions are generated by analyzing:
 * - Current pattern sequences
 * - Setup progress and historical outcomes
 * - Technical and options context
 * - Historical pattern success rates
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PredictedEvent {

    /**
     * Unique prediction ID
     */
    private String predictionId;

    /**
     * Family this prediction applies to
     */
    private String familyId;

    /**
     * Type of predicted event
     */
    private PredictionType type;

    /**
     * Direction of predicted move
     */
    private PredictionDirection direction;

    /**
     * Time frame for prediction
     */
    private TimeFrame timeFrame;

    // ======================== PREDICTION DETAILS ========================

    /**
     * Confidence in this prediction (0-1)
     */
    private double confidence;

    /**
     * Expected probability of occurrence (0-1)
     */
    private double probability;

    /**
     * Description of what is predicted
     */
    private String description;

    /**
     * Rationale for prediction
     */
    private String rationale;

    // ======================== PRICE TARGETS ========================

    /**
     * Current price when prediction made
     */
    private double currentPrice;

    /**
     * Predicted target price
     */
    private Double targetPrice;

    /**
     * Predicted price range - low
     */
    private Double targetRangeLow;

    /**
     * Predicted price range - high
     */
    private Double targetRangeHigh;

    /**
     * Expected move percentage
     */
    private Double expectedMovePct;

    /**
     * Key level that would invalidate prediction
     */
    private Double invalidationPrice;

    // ======================== TIMING ========================

    /**
     * When prediction was generated
     */
    private Instant generatedAt;

    /**
     * Expected time range start
     */
    private Instant expectedFrom;

    /**
     * Expected time range end
     */
    private Instant expectedBy;

    /**
     * When prediction expires (no longer valid)
     */
    private Instant expiresAt;

    // ======================== CONTEXT ========================

    /**
     * What triggered this prediction
     */
    private List<String> triggerConditions;

    /**
     * Setup ID if prediction based on setup
     */
    private String setupId;

    /**
     * Pattern ID if prediction based on pattern
     */
    private String patternId;

    /**
     * Historical success rate for similar predictions
     */
    private double historicalSuccessRate;

    /**
     * Number of historical samples
     */
    private int historicalSampleCount;

    // ======================== OUTCOME TRACKING ========================

    /**
     * Current status of prediction
     */
    @Builder.Default
    private PredictionStatus status = PredictionStatus.ACTIVE;

    /**
     * Actual outcome (filled after resolution)
     */
    private PredictionOutcome outcome;

    /**
     * When prediction was resolved
     */
    private Instant resolvedAt;

    /**
     * Actual result if resolved
     */
    private String actualResult;

    // ======================== ENUMS ========================

    public enum PredictionType {
        PRICE_TARGET,           // Price will reach a specific level
        DIRECTION_CHANGE,       // Direction will change (reversal)
        BREAKOUT,               // Price will break a level
        BREAKDOWN,              // Price will break down
        VOLATILITY_EXPANSION,   // Volatility will expand
        VOLATILITY_CONTRACTION, // Volatility will contract
        SUPPORT_TEST,           // Price will test support
        RESISTANCE_TEST,        // Price will test resistance
        TREND_CONTINUATION,     // Trend will continue
        MEAN_REVERSION,         // Price will revert to mean
        GAP_FILL,               // Gap will be filled
        MAX_PAIN_MAGNET,        // Price will move toward max pain
        GAMMA_SQUEEZE,          // Gamma squeeze expected
        ABSORPTION_BOUNCE,      // Price will bounce after absorption
        EXHAUSTION_REVERSAL     // Reversal after exhaustion
    }

    public enum PredictionDirection {
        BULLISH,
        BEARISH,
        NEUTRAL,
        EITHER
    }

    public enum TimeFrame {
        IMMEDIATE(15),          // 0-15 minutes
        SHORT_TERM(60),         // 15-60 minutes
        MEDIUM_TERM(240),       // 1-4 hours
        END_OF_DAY(480),        // By end of trading day
        MULTI_DAY(1440);        // 1+ days

        private final int maxMinutes;

        TimeFrame(int maxMinutes) {
            this.maxMinutes = maxMinutes;
        }

        public int getMaxMinutes() {
            return maxMinutes;
        }
    }

    public enum PredictionStatus {
        ACTIVE,         // Prediction is active
        IN_PROGRESS,    // Event is materializing
        RESOLVED,       // Prediction resolved (hit target or invalidated)
        EXPIRED,        // Prediction expired without resolution
        CANCELLED       // Prediction cancelled due to context change
    }

    public enum PredictionOutcome {
        CORRECT,        // Prediction was correct
        PARTIALLY_CORRECT, // Prediction partially correct
        INCORRECT,      // Prediction was wrong
        INDETERMINATE   // Could not determine outcome
    }

    // ======================== HELPER METHODS ========================

    /**
     * Check if prediction is still active
     */
    public boolean isActive() {
        return status == PredictionStatus.ACTIVE || status == PredictionStatus.IN_PROGRESS;
    }

    /**
     * Check if prediction has expired
     */
    public boolean hasExpired() {
        return expiresAt != null && Instant.now().isAfter(expiresAt);
    }

    /**
     * Check if prediction has resolved
     */
    public boolean isResolved() {
        return status == PredictionStatus.RESOLVED || status == PredictionStatus.EXPIRED;
    }

    /**
     * Get time remaining in minutes
     */
    public long getTimeRemainingMinutes() {
        if (expiresAt == null) return -1;
        long remaining = (expiresAt.toEpochMilli() - Instant.now().toEpochMilli()) / 60000;
        return Math.max(0, remaining);
    }

    /**
     * Calculate expected risk/reward
     */
    public double getRiskReward() {
        if (currentPrice == 0 || targetPrice == null || invalidationPrice == null) {
            return 0;
        }
        double reward = Math.abs(targetPrice - currentPrice);
        double risk = Math.abs(currentPrice - invalidationPrice);
        return risk > 0 ? reward / risk : 0;
    }

    /**
     * Mark as in progress
     */
    public void markInProgress() {
        this.status = PredictionStatus.IN_PROGRESS;
    }

    /**
     * Resolve prediction
     */
    public void resolve(PredictionOutcome outcome, String result) {
        this.status = PredictionStatus.RESOLVED;
        this.outcome = outcome;
        this.actualResult = result;
        this.resolvedAt = Instant.now();
    }

    /**
     * Expire prediction
     */
    public void expire() {
        this.status = PredictionStatus.EXPIRED;
        this.resolvedAt = Instant.now();
    }

    /**
     * Cancel prediction
     */
    public void cancel(String reason) {
        this.status = PredictionStatus.CANCELLED;
        this.actualResult = "Cancelled: " + reason;
        this.resolvedAt = Instant.now();
    }

    /**
     * Get confidence as percentage string
     */
    public String getConfidenceStr() {
        return String.format("%.0f%%", confidence * 100);
    }

    /**
     * Get short description
     */
    public String getShortDescription() {
        return String.format("%s %s (%s, %s)",
                type.name().replace("_", " "),
                direction.name().toLowerCase(),
                timeFrame.name().replace("_", " ").toLowerCase(),
                getConfidenceStr());
    }

    @Override
    public String toString() {
        return String.format("Prediction[%s] %s %s: %s (%.0f%% confidence, %s)",
                predictionId != null ? predictionId.substring(0, 8) : "NEW",
                direction, type, description,
                confidence * 100, status);
    }
}
